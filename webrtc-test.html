<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebRTC –¢–µ—Å—Ç</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: black;
            color: #00d4ff;
            font-family: monospace;
            text-align: center;
        }
        #square {
            width: 200px;
            height: 200px;
            background: red;
            margin: 20px auto;
            border: 3px solid #00d4ff;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            font-weight: bold;
        }
        #status {
            padding: 10px;
            border: 2px solid #f00;
            margin: 10px 0;
            background: rgba(255,0,0,0.1);
        }
        #code {
            font-size: 24px;
            font-weight: bold;
            margin: 20px;
            padding: 15px;
            border: 2px solid #00d4ff;
            background: rgba(0,212,255,0.1);
        }
        #log {
            height: 200px;
            overflow-y: auto;
            border: 1px solid #00d4ff;
            padding: 10px;
            text-align: left;
            background: rgba(0,0,0,0.3);
        }
        .log-entry {
            margin: 2px 0;
        }
        input {
            padding: 10px;
            font-size: 16px;
            margin: 5px;
            background: black;
            color: #00d4ff;
            border: 1px solid #00d4ff;
        }
        button {
            padding: 10px 20px;
            background: #00d4ff;
            color: black;
            border: none;
            cursor: pointer;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <h1>WebRTC –ü—Ä—è–º–∞—è –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è</h1>
    
    <div id="status">–ù–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–æ</div>
    
    <div id="code">–ö–æ–¥: –ì–ï–ù–ï–†–ò–†–£–ï–¢–°–Ø...</div>
    
    <div>
        <input type="text" id="connectCode" placeholder="–í–≤–µ–¥–∏—Ç–µ –∫–æ–¥ –¥–ª—è –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è">
        <button onclick="connectToPeer()">–ü–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è</button>
    </div>
    
    <div id="square" onclick="toggleSquare()">–ö—Ä–∞—Å–Ω—ã–π!</div>
    
    <div class="info">
        <p><b>–ò–Ω—Å—Ç—Ä—É–∫—Ü–∏—è:</b></p>
        <p>1. –û—Ç–∫—Ä–æ–π—Ç–µ —ç—Ç—É —Å—Ç—Ä–∞–Ω–∏—Ü—É –Ω–∞ –¥–≤—É—Ö —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞—Ö</p>
        <p>2. –ù–∞ –≤—Ç–æ—Ä–æ–º —É—Å—Ç—Ä–æ–π—Å—Ç–≤–µ –≤–≤–µ–¥–∏—Ç–µ –∫–æ–¥ —Å –ø–µ—Ä–≤–æ–≥–æ –∏ –Ω–∞–∂–º–∏—Ç–µ "–ü–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è"</p>
        <p>3. –ö–ª–∏–∫–∞–π—Ç–µ –Ω–∞ –∫–≤–∞–¥—Ä–∞—Ç - –æ–Ω —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä—É–µ—Ç—Å—è!</p>
    </div>
    
    <div id="log"></div>

    <script>
        let isGreen = false;
        let peer = null;
        let dataChannel = null;
        let myCode = Math.random().toString(36).substr(2, 6).toUpperCase();

        function log(message) {
            const logDiv = document.getElementById('log');
            const entry = document.createElement('div');
            entry.className = 'log-entry';
            entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            logDiv.appendChild(entry);
            logDiv.scrollTop = logDiv.scrollHeight;
            console.log(message);
        }

        // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –∫–æ–¥ –¥–ª—è –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è
        document.getElementById('code').textContent = `–ö–æ–¥: ${myCode}`;

        // –°–æ–∑–¥–∞–µ–º —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ
        function createConnection() {
            peer = new RTCPeerConnection({
                iceServers: [
                    { urls: 'stun:stun.l.google.com:19302' },
                    { urls: 'stun:stun1.l.google.com:19302' }
                ]
            });

            peer.onicecandidate = (event) => {
                if (event.candidate) {
                    log('üßä ICE candidate: ' + event.candidate.candidate.substring(0, 50) + '...');
                }
            };

            peer.onconnectionstatechange = () => {
                log('üîó –°–æ—Å—Ç–æ—è–Ω–∏–µ: ' + peer.connectionState);
                if (peer.connectionState === 'connected') {
                    document.getElementById('status').textContent = '–ü–æ–¥–∫–ª—é—á–µ–Ω–æ ‚úÖ';
                    document.getElementById('status').style.borderColor = '#0f0';
                } else if (peer.connectionState === 'failed') {
                    document.getElementById('status').textContent = '–û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è';
                    document.getElementById('status').style.borderColor = '#f00';
                }
            };

            return peer;
        }

        // –°–æ–∑–¥–∞–µ–º –∫–∞–Ω–∞–ª –¥–∞–Ω–Ω—ã—Ö
        function setupDataChannel(channel) {
            dataChannel = channel;
            
            dataChannel.onopen = () => {
                log('‚úÖ –ö–∞–Ω–∞–ª –¥–∞–Ω–Ω—ã—Ö –æ—Ç–∫—Ä—ã—Ç');
            };
            
            dataChannel.onmessage = (event) => {
                const data = JSON.parse(event.data);
                if (data.isGreen !== isGreen) {
                    isGreen = data.isGreen;
                    updateSquare(false);
                    log('üì• –ü–æ–ª—É—á–µ–Ω–æ: ' + (isGreen ? '–∑–µ–ª—ë–Ω—ã–π' : '–∫—Ä–∞—Å–Ω—ã–π'));
                }
            };
            
            dataChannel.onerror = (error) => {
                log('‚ùå –û—à–∏–±–∫–∞ –∫–∞–Ω–∞–ª–∞: ' + error);
            };
        }

        // –ü–æ–¥–∫–ª—é—á–∞–µ–º—Å—è –∫ –¥—Ä—É–≥–æ–º—É —É—Å—Ç—Ä–æ–π—Å—Ç–≤—É
        async function connectToPeer() {
            const code = document.getElementById('connectCode').value.trim().toUpperCase();
            if (!code) {
                alert('–í–≤–µ–¥–∏—Ç–µ –∫–æ–¥!');
                return;
            }

            log('üîÑ –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫: ' + code);
            
            const connection = createConnection();
            const channel = connection.createDataChannel('sync');
            setupDataChannel(channel);

            // –°–æ–∑–¥–∞–µ–º offer
            const offer = await connection.createOffer();
            await connection.setLocalDescription(offer);

            // –°–∏–º—É–ª–∏—Ä—É–µ–º –æ–±–º–µ–Ω —á–µ—Ä–µ–∑ –∫–æ–¥ (–≤ —Ä–µ–∞–ª—å–Ω–æ—Å—Ç–∏ –Ω—É–∂–µ–Ω —Å–∏–≥–Ω–∞–ª—å–Ω—ã–π —Å–µ—Ä–≤–µ—Ä)
            localStorage.setItem('offer-' + code, JSON.stringify(offer));
            log('üì§ Offer –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω');

            // –ñ–¥–µ–º –æ—Ç–≤–µ—Ç
            waitForAnswer(code, connection);
        }

        // –ñ–¥–µ–º –≤—Ö–æ–¥—è—â–∏–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è
        function waitForConnections() {
            setInterval(() => {
                const offer = localStorage.getItem('offer-' + myCode);
                if (offer && !peer) {
                    log('üì• –ü–æ–ª—É—á–µ–Ω offer');
                    handleIncomingConnection(JSON.parse(offer));
                    localStorage.removeItem('offer-' + myCode);
                }
            }, 1000);
        }

        // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –≤—Ö–æ–¥—è—â–µ–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ
        async function handleIncomingConnection(offer) {
            const connection = createConnection();
            
            connection.ondatachannel = (event) => {
                setupDataChannel(event.channel);
            };

            await connection.setRemoteDescription(offer);
            const answer = await connection.createAnswer();
            await connection.setLocalDescription(answer);

            // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –æ—Ç–≤–µ—Ç
            localStorage.setItem('answer-' + myCode, JSON.stringify(answer));
            log('üì§ Answer –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω');

            peer = connection;
        }

        // –ñ–¥–µ–º –æ—Ç–≤–µ—Ç
        function waitForAnswer(code, connection) {
            const checkAnswer = setInterval(() => {
                const answer = localStorage.getItem('answer-' + code);
                if (answer) {
                    log('üì• –ü–æ–ª—É—á–µ–Ω answer');
                    connection.setRemoteDescription(JSON.parse(answer));
                    localStorage.removeItem('answer-' + code);
                    peer = connection;
                    clearInterval(checkAnswer);
                }
            }, 1000);

            // –¢–∞–π–º–∞—É—Ç 30 —Å–µ–∫—É–Ω–¥
            setTimeout(() => {
                clearInterval(checkAnswer);
                if (!peer) {
                    log('‚è∞ –¢–∞–π–º–∞—É—Ç –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è');
                }
            }, 30000);
        }

        function toggleSquare() {
            isGreen = !isGreen;
            updateSquare(true);
            
            if (dataChannel && dataChannel.readyState === 'open') {
                dataChannel.send(JSON.stringify({ isGreen: isGreen }));
                log('üì§ –û—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ: ' + (isGreen ? '–∑–µ–ª—ë–Ω—ã–π' : '–∫—Ä–∞—Å–Ω—ã–π'));
            }
        }

        function updateSquare(notify = true) {
            const square = document.getElementById('square');
            square.style.background = isGreen ? 'green' : 'red';
            square.textContent = isGreen ? '–ó–µ–ª—ë–Ω—ã–π!' : '–ö—Ä–∞—Å–Ω—ã–π!';
            
            if (notify) {
                log('üé® –ö–≤–∞–¥—Ä–∞—Ç: ' + (isGreen ? '–∑–µ–ª—ë–Ω—ã–π' : '–∫—Ä–∞—Å–Ω—ã–π'));
            }
        }

        // –ó–∞–ø—É—Å–∫–∞–µ–º
        window.addEventListener('load', () => {
            log('üöÄ –°—Ç—Ä–∞–Ω–∏—Ü–∞ –∑–∞–≥—Ä—É–∂–µ–Ω–∞');
            log('üîë –ú–æ–π –∫–æ–¥: ' + myCode);
            waitForConnections();
        });
    </script>
</body>
</html>